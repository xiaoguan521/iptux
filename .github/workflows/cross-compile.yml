name: cross-compile

on:
  workflow_dispatch:
    inputs:
      target_arch:
        description: '目标架构'
        required: true
        default: 'aarch64'
        type: choice
        options:
          - aarch64
          - armv7
          - riscv64

env:
  DEB_PKGS: >-
    g++ meson appstream gettext libgoogle-glog-dev libgtk-3-dev libglib2.0-dev
    libjsoncpp-dev libsigc++-2.0-dev libayatana-appindicator3-dev

jobs:
  cross-compile:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ${{ env.DEB_PKGS }}
          
      - name: Setup multiarch support
        run: |
          if [ "${{ github.event.inputs.target_arch }}" == "aarch64" ]; then
            # 添加ARM64架构
            sudo dpkg --add-architecture arm64
            
            # 使用单行命令创建ARM64架构的软件源配置
            echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble main universe restricted multiverse" | sudo tee /etc/apt/sources.list.d/arm64.list
            echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble-updates main universe restricted multiverse" | sudo tee -a /etc/apt/sources.list.d/arm64.list
            echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble-backports main universe restricted multiverse" | sudo tee -a /etc/apt/sources.list.d/arm64.list
            echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble-security main universe restricted multiverse" | sudo tee -a /etc/apt/sources.list.d/arm64.list
            
            # 修改主源列表，限制为仅获取amd64的包
            sudo sed -i 's/^deb http/deb [arch=amd64] http/g' /etc/apt/sources.list
            
            # 更新软件源，忽略错误继续执行
            sudo apt-get update || echo "软件源更新出错，但将继续执行"
          elif [ "${{ github.event.inputs.target_arch }}" == "armv7" ]; then
            # 添加ARMHF架构
            sudo dpkg --add-architecture armhf
            
            # 使用单行命令创建ARMHF架构的软件源配置
            echo "deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports noble main universe restricted multiverse" | sudo tee /etc/apt/sources.list.d/armhf.list
            echo "deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports noble-updates main universe restricted multiverse" | sudo tee -a /etc/apt/sources.list.d/armhf.list
            echo "deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports noble-backports main universe restricted multiverse" | sudo tee -a /etc/apt/sources.list.d/armhf.list
            echo "deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports noble-security main universe restricted multiverse" | sudo tee -a /etc/apt/sources.list.d/armhf.list
            
            # 修改主源列表，限制为仅获取amd64的包
            sudo sed -i 's/^deb http/deb [arch=amd64] http/g' /etc/apt/sources.list
            
            # 更新软件源，忽略错误继续执行
            sudo apt-get update || echo "软件源更新出错，但将继续执行"
          elif [ "${{ github.event.inputs.target_arch }}" == "riscv64" ]; then
            # RISC-V 可能需要专门的仓库
            echo "RISC-V 架构可能需要额外配置"
          fi
          
      - name: Install cross-compilation toolchain
        run: |
          if [ "${{ github.event.inputs.target_arch }}" == "aarch64" ]; then
            # 安装交叉编译工具链，失败时立即退出
            echo "安装ARM64交叉编译工具链..."
            sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
            
            # 验证交叉编译工具是否可用
            which aarch64-linux-gnu-gcc || { echo "错误: 找不到aarch64-linux-gnu-gcc"; exit 1; }
            which aarch64-linux-gnu-g++ || { echo "错误: 找不到aarch64-linux-gnu-g++"; exit 1; }
            
            # 显示版本信息
            aarch64-linux-gnu-gcc --version
            aarch64-linux-gnu-g++ --version
            
            # 安装所有关键依赖的ARM64版本
            echo "安装 ARM64 架构依赖库..."
            sudo apt-get install -y --no-install-recommends \
              libglib2.0-dev:arm64 \
              libgtk-3-dev:arm64 \
              libjsoncpp-dev:arm64 \
              libsigc++-2.0-dev:arm64 \
              libgoogle-glog-dev:arm64 \
              libayatana-appindicator3-dev:arm64 \
              || echo "某些ARM64依赖库安装失败，但将继续执行"
              
            sudo apt-get install -y crossbuild-essential-arm64 || echo "crossbuild-essential安装失败，但将继续执行"
            
            # 创建pkgconfig符号链接以确保能找到arm64架构的.pc文件
            echo "配置pkg-config以查找ARM64库..."
            sudo mkdir -p /usr/share/pkgconfig-arm64
            sudo find /usr/lib/aarch64-linux-gnu/pkgconfig -name "*.pc" -exec ln -sf {} /usr/share/pkgconfig-arm64/ \;
            
            # 设置环境变量
            echo "CROSS_TRIPLE=aarch64-linux-gnu" >> $GITHUB_ENV
            echo "CROSS_PKG_CONFIG_PATH=/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig-arm64:/usr/share/pkgconfig" >> $GITHUB_ENV
            echo "PKG_CONFIG_PATH=/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig-arm64:/usr/share/pkgconfig" >> $GITHUB_ENV
            
            # 创建jsoncpp的特殊配置，确保能找到它
            echo "创建特定的pkg-config配置文件..."
            if [ -f "/usr/lib/aarch64-linux-gnu/pkgconfig/jsoncpp.pc" ]; then
              sudo cp /usr/lib/aarch64-linux-gnu/pkgconfig/jsoncpp.pc /usr/share/pkgconfig-arm64/
              echo "已复制 jsoncpp.pc 到共享目录"
            else
              # 如果没有找到jsoncpp.pc，手动创建一个
              echo "未找到jsoncpp.pc，创建一个临时版本..."
              cat > jsoncpp.pc << EOF
Name: jsoncpp
Description: A JSON implementation in C++
Version: 1.9.5
Libs: -L/usr/lib/aarch64-linux-gnu -ljsoncpp
Cflags: -I/usr/include/jsoncpp
EOF
              sudo cp jsoncpp.pc /usr/share/pkgconfig-arm64/
            fi
            
            # 显示环境信息
            echo "pkg-config可用的库:"
            PKG_CONFIG_PATH="/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig-arm64:/usr/share/pkgconfig" pkg-config --list-all | grep -i json || true
            
            # 直接修复pkg-config问题的备用方法
            echo "PKG_CONFIG_ALLOW_SYSTEM_LIBS=1" >> $GITHUB_ENV
            echo "PKG_CONFIG_ALLOW_SYSTEM_CFLAGS=1" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.target_arch }}" == "armv7" ]; then
            sudo apt-get install -y gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf
            
            # 安装所有依赖的ARMHF版本
            sudo apt-get install -y --no-install-recommends \
              libglib2.0-dev:armhf \
              libgtk-3-dev:armhf \
              libjsoncpp-dev:armhf \
              libsigc++-2.0-dev:armhf \
              libgoogle-glog-dev:armhf \
              libayatana-appindicator3-dev:armhf \
              || echo "某些ARMHF依赖库安装失败，但将继续执行"
            
            # 创建pkgconfig符号链接
            sudo mkdir -p /usr/share/pkgconfig-armhf
            sudo find /usr/lib/arm-linux-gnueabihf/pkgconfig -name "*.pc" -exec ln -sf {} /usr/share/pkgconfig-armhf/ \;
            
            echo "CROSS_TRIPLE=arm-linux-gnueabihf" >> $GITHUB_ENV
            echo "CROSS_PKG_CONFIG_PATH=/usr/lib/arm-linux-gnueabihf/pkgconfig:/usr/share/pkgconfig-armhf:/usr/share/pkgconfig" >> $GITHUB_ENV
            echo "PKG_CONFIG_PATH=/usr/lib/arm-linux-gnueabihf/pkgconfig:/usr/share/pkgconfig-armhf:/usr/share/pkgconfig" >> $GITHUB_ENV
            echo "PKG_CONFIG_ALLOW_SYSTEM_LIBS=1" >> $GITHUB_ENV
            echo "PKG_CONFIG_ALLOW_SYSTEM_CFLAGS=1" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.target_arch }}" == "riscv64" ]; then
            sudo apt-get install -y gcc-riscv64-linux-gnu g++-riscv64-linux-gnu
            # RISC-V 可能需要其他方法
            echo "CROSS_TRIPLE=riscv64-linux-gnu" >> $GITHUB_ENV
            echo "CROSS_PKG_CONFIG_PATH=/usr/lib/riscv64-linux-gnu/pkgconfig:/usr/share/pkgconfig" >> $GITHUB_ENV
          fi
      
      - name: Prepare cross compilation configuration
        run: |
          mkdir -p cross-files
          
          # 先设置变量便于替换
          CROSS_SYS_ROOT="/usr/${{ env.CROSS_TRIPLE }}"
          CROSS_PKG_CONFIG_LIBDIR="${{ env.CROSS_PKG_CONFIG_PATH }}"
          
          cat > cross-files/${{ github.event.inputs.target_arch }}.txt << EOF
          [binaries]
          c = '${{ env.CROSS_TRIPLE }}-gcc'
          cpp = '${{ env.CROSS_TRIPLE }}-g++'
          ar = '${{ env.CROSS_TRIPLE }}-ar'
          strip = '${{ env.CROSS_TRIPLE }}-strip'
          pkg-config = 'pkg-config'
          
          [built-in options]
          pkg_config_path = '${{ env.CROSS_PKG_CONFIG_PATH }}'
          
          [properties]
          needs_exe_wrapper = true
          sys_root = '${CROSS_SYS_ROOT}'
          pkg_config_libdir = '${CROSS_PKG_CONFIG_LIBDIR}'
          
          [host_machine]
          system = 'linux'
          cpu_family = '${{ github.event.inputs.target_arch }}'
          cpu = '${{ github.event.inputs.target_arch }}'
          endian = 'little'
          EOF
          
          if [ "${{ github.event.inputs.target_arch }}" == "armv7" ]; then
            # 对于 armv7 架构需要指定具体的CPU系列
            sed -i 's/cpu_family = .*/cpu_family = "arm"/' cross-files/${{ github.event.inputs.target_arch }}.txt
            sed -i 's/cpu = .*/cpu = "armv7-a"/' cross-files/${{ github.event.inputs.target_arch }}.txt
          fi
      
      - name: Configure
        run: |
          mkdir -p build
          
          # 输出调试信息
          echo "===== 交叉编译环境信息 ====="
          echo "目标架构: ${{ github.event.inputs.target_arch }}"
          echo "编译器: ${{ env.CROSS_TRIPLE }}-gcc"
          echo "pkg-config路径: ${{ env.CROSS_PKG_CONFIG_PATH }}"
          echo "PKG_CONFIG_PATH: ${{ env.PKG_CONFIG_PATH }}"
          echo "交叉编译配置文件内容:"
          cat cross-files/${{ github.event.inputs.target_arch }}.txt
          
          # 测试pkg-config能否找到关键依赖
          echo "测试pkg-config是否能找到jsoncpp:"
          PKG_CONFIG_PATH="${{ env.PKG_CONFIG_PATH }}" pkg-config --exists --print-errors jsoncpp || echo "警告: pkg-config无法找到jsoncpp，但将继续尝试"
          
          echo "测试pkg-config是否能找到glib-2.0:"
          PKG_CONFIG_PATH="${{ env.PKG_CONFIG_PATH }}" pkg-config --exists --print-errors glib-2.0 || echo "警告: pkg-config无法找到glib-2.0，但将继续尝试"
          echo "=========================="
          
          # 检查编译器可用性
          which ${{ env.CROSS_TRIPLE }}-gcc || { echo "错误: 找不到 ${{ env.CROSS_TRIPLE }}-gcc"; exit 1; }
          which ${{ env.CROSS_TRIPLE }}-g++ || { echo "错误: 找不到 ${{ env.CROSS_TRIPLE }}-g++"; exit 1; }
          
          # 创建自定义jsoncpp查找模块
          mkdir -p $(pwd)/meson_modules
          cat > $(pwd)/meson_modules/FindJsoncpp.cmake << 'EOF'
          set(JSONCPP_INCLUDE_DIRS /usr/include/jsoncpp)
          set(JSONCPP_LIBRARIES jsoncpp)
          set(JSONCPP_FOUND TRUE)
          EOF
          
          # 设置环境变量以处理特殊依赖
          export PKG_CONFIG_PATH="${{ env.PKG_CONFIG_PATH }}"
          export CMAKE_PREFIX_PATH="$(pwd)/meson_modules:$CMAKE_PREFIX_PATH"
          
          # 导出一些调试信息
          export MESON_DEBUG=1
          
          # 配置构建 - 使用基本配置，不包括未知选项
          MESON_ARGS="--buildtype=release -Db_lto=false"
          
          echo "运行第一次尝试配置..."
          meson setup build \
            --cross-file=cross-files/${{ github.event.inputs.target_arch }}.txt \
            $MESON_ARGS \
            -Dauto_features=disabled || \
          {
            echo "第一次尝试失败，使用静态库尝试..."
            meson setup build \
              --cross-file=cross-files/${{ github.event.inputs.target_arch }}.txt \
              $MESON_ARGS \
              -Ddefault_library=static \
              -Dauto_features=disabled || \
            {
              echo "第二次尝试失败，尝试手动指定依赖..."
              # 如果jsoncpp相关选项可用，添加自定义路径
              meson setup --wipe build \
                --cross-file=cross-files/${{ github.event.inputs.target_arch }}.txt \
                $MESON_ARGS \
                -Dauto_features=disabled \
                -Dc_args="-I/usr/include/jsoncpp" \
                -Dc_link_args="-ljsoncpp" \
                -Dcpp_args="-I/usr/include/jsoncpp" \
                -Dcpp_link_args="-ljsoncpp" \
                || {
                  echo "第三次尝试失败，尝试使用最小化配置..."
                  meson setup --wipe build \
                    --cross-file=cross-files/${{ github.event.inputs.target_arch }}.txt \
                    --buildtype=release
                }
            }
          }
      
      - name: Build
        run: |
          meson compile -C build -v
      
      - name: Package
        run: |
          mkdir -p pkg
          DESTDIR=$(pwd)/pkg meson install -C build
          
          # 创建部署脚本
          cat > pkg/install.sh << 'EOF'
          #!/bin/bash
          # iptux 安装脚本
          
          # 检查是否以root运行
          if [ "$(id -u)" != "0" ]; then
            echo "请以root权限运行此脚本"
            exit 1
          fi
          
          # 安装目录
          INSTALL_DIR="/usr/local"
          
          # 创建目录（如果不存在）
          mkdir -p $INSTALL_DIR/bin
          mkdir -p $INSTALL_DIR/lib
          mkdir -p $INSTALL_DIR/share
          
          # 复制文件
          echo "正在安装iptux..."
          cp -r usr/local/bin/* $INSTALL_DIR/bin/ 2>/dev/null || echo "警告：bin目录复制失败或为空"
          cp -r usr/local/lib/* $INSTALL_DIR/lib/ 2>/dev/null || echo "警告：lib目录复制失败或为空" 
          cp -r usr/local/share/* $INSTALL_DIR/share/ 2>/dev/null || echo "警告：share目录复制失败或为空"
          cp -r usr/bin/* $INSTALL_DIR/bin/ 2>/dev/null || true
          cp -r usr/lib/* $INSTALL_DIR/lib/ 2>/dev/null || true
          cp -r usr/share/* $INSTALL_DIR/share/ 2>/dev/null || true
          
          # 设置可执行权限
          find $INSTALL_DIR/bin -type f -exec chmod +x {} \; 2>/dev/null
          
          # 运行ldconfig更新共享库缓存
          echo "更新共享库缓存..."
          ldconfig
          
          echo "安装完成！请确保安装以下依赖:"
          cat dependencies.txt
          
          echo "iptux现在可以从命令行启动: iptux"
          EOF
          
          # 设置部署脚本权限
          chmod +x pkg/install.sh
          
          # 创建依赖列表
          cat > pkg/dependencies.txt << EOF
          # 以下是运行iptux所需的依赖
          libgtk-3-0
          libglib2.0-0
          libjsoncpp25 (或libjsoncpp24，取决于系统版本)
          libsigc++-2.0-0v5
          libgoogle-glog0v5
          libayatana-appindicator3-1
          
          # 安装命令参考
          # 对于Debian/Ubuntu系统:
          apt-get install -y libgtk-3-0 libglib2.0-0 libjsoncpp25 libsigc++-2.0-0v5 libgoogle-glog0v5 libayatana-appindicator3-1
          EOF
          
          # 创建一个README文件
          cat > pkg/README.md << EOF
          # iptux ${{ github.event.inputs.target_arch }} 安装指南
          
          ## 安装方法
          
          1. 解压安装包: \`tar xzf iptux-${{ github.event.inputs.target_arch }}.tar.gz\`
          2. 确保您正在 ${{ github.event.inputs.target_arch }} 架构的设备上安装
          3. 安装依赖: \`sudo apt-get install -y \$(grep -v "^#" dependencies.txt | grep -v "取决于系统版本" | tr '\n' ' ')\`
          4. 以root权限运行安装脚本: \`sudo ./install.sh\`
          
          ## 故障排除
          
          如果遇到"共享库缺失"的错误，请确保已安装所有dependencies.txt中列出的依赖。
          
          ## 手动安装方法
          
          如果安装脚本不能正常工作，您可以手动安装:
          
          \`\`\`bash
          sudo mkdir -p /usr/local/bin /usr/local/lib /usr/local/share
          sudo cp -r usr/local/bin/* /usr/local/bin/ 2>/dev/null || true
          sudo cp -r usr/local/lib/* /usr/local/lib/ 2>/dev/null || true
          sudo cp -r usr/local/share/* /usr/local/share/ 2>/dev/null || true
          sudo cp -r usr/bin/* /usr/local/bin/ 2>/dev/null || true
          sudo cp -r usr/lib/* /usr/local/lib/ 2>/dev/null || true
          sudo cp -r usr/share/* /usr/local/share/ 2>/dev/null || true
          sudo find /usr/local/bin -type f -exec chmod +x {} \; 2>/dev/null
          sudo ldconfig
          \`\`\`
          EOF
          
          # 打包所有文件为tar.gz
          cd pkg
          tar czf ../iptux-${{ github.event.inputs.target_arch }}.tar.gz *
          cd ..
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4.6.1
        with:
          name: iptux-${{ github.event.inputs.target_arch }}
          path: |
            pkg/
            iptux-${{ github.event.inputs.target_arch }}.tar.gz
          retention-days: 7 