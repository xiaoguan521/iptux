name: docker-cross-compile

on:
  workflow_dispatch:
    inputs:
      target_arch:
        description: '目标架构'
        required: true
        default: 'aarch64'
        type: choice
        options:
          - aarch64
          - arm32v7
          - riscv64

env:
  DEB_PKGS: >-
    g++ meson ninja-build appstream gettext libgoogle-glog-dev libgtk-3-dev libglib2.0-dev
    libjsoncpp-dev libsigc++-2.0-dev libayatana-appindicator3-dev

jobs:
  docker-cross-compile:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Enable QEMU support
        run: |
          docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
          # 检查QEMU是否正确安装
          ls -la /proc/sys/fs/binfmt_misc/
          echo "QEMU支持已启用"
      
      - name: Cross-compile based on successful approach
        run: |
          # 选择合适的Docker镜像和平台
          if [ "${{ github.event.inputs.target_arch }}" == "aarch64" ]; then
            DOCKER_IMAGE="ubuntu:22.04"
            DOCKER_PLATFORM="linux/arm64"
            CROSS_ARCH="arm64"
          elif [ "${{ github.event.inputs.target_arch }}" == "arm32v7" ]; then
            DOCKER_IMAGE="ubuntu:22.04"
            DOCKER_PLATFORM="linux/arm/v7"
            CROSS_ARCH="armhf" 
          elif [ "${{ github.event.inputs.target_arch }}" == "riscv64" ]; then
            DOCKER_IMAGE="ubuntu:22.04"
            DOCKER_PLATFORM="linux/riscv64"
            CROSS_ARCH="riscv64"
          fi
          
          echo "使用镜像: $DOCKER_IMAGE 平台: $DOCKER_PLATFORM"
          
          # 预先拉取镜像以验证Docker运行正常
          echo "预拉取Docker镜像..."
          docker pull --platform $DOCKER_PLATFORM $DOCKER_IMAGE
          
          # 验证Docker能否正常启动目标架构容器
          echo "验证Docker平台支持..."
          docker run --rm --platform $DOCKER_PLATFORM $DOCKER_IMAGE uname -a || {
            echo "错误：无法运行目标平台容器，可能QEMU支持未正确配置"
            exit 1
          }
          
          # 在目标架构的容器中直接编译，使用--platform指定目标架构
          docker run --rm -v $(pwd):/iptux -w /iptux \
            --platform $DOCKER_PLATFORM \
            $DOCKER_IMAGE /bin/bash -c "
            set -ex
            
            # 输出系统信息进行验证
            echo '当前系统架构:'
            uname -a
            
            # 确保apt源可用
            echo '检查apt源...'
            cat /etc/apt/sources.list
            
            # 更新并安装依赖，增加错误处理
            echo '更新软件源...'
            apt-get update || { echo '软件源更新失败，但将继续执行'; }
            
            echo '安装构建依赖...'
            apt-get install -y --no-install-recommends ${{ env.DEB_PKGS }} || {
              echo '完整依赖安装失败，尝试安装基本依赖';
              apt-get install -y --no-install-recommends g++ meson ninja-build gettext libjsoncpp-dev libsigc++-2.0-dev;
            }
            
            # 验证关键工具已安装
            which g++ || { echo '错误：g++ 未找到'; exit 1; }
            which meson || { echo '错误：meson 未找到'; exit 1; }
            
            echo '开始配置项目...'
            # 使用与成功workflow相同的构建命令，增加容错选项
            meson setup build --buildtype=release || \
            meson setup build --buildtype=release -Dauto_features=disabled || \
            meson setup build --buildtype=release -Ddefault_library=static -Dauto_features=disabled || {
              echo '配置失败';
              exit 1;
            }
            
            echo '开始编译...'
            ninja -C build || {
              echo '编译失败';
              exit 1;
            }
            
            # 创建安装目录并安装
            echo '安装到临时目录...'
            mkdir -p pkg
            DESTDIR=\$(pwd)/pkg meson install -C build
          "
          
          # 检查编译是否成功完成
          if [ ! -d "pkg" ]; then
            echo "错误：编译过程未完成，未生成安装包"
            exit 1
          fi
          
      - name: Create deployment package
        run: |
          echo "创建部署包..."
          # 检查pkg目录是否存在
          if [ ! -d "pkg" ]; then
            echo "错误：pkg目录不存在，无法创建部署包"
            mkdir -p pkg
            echo "已创建空的pkg目录"
          fi
          
          # 检查安装包内容
          echo "安装包内容:"
          find pkg -type f | grep -v "\.a$" | head -20
          
          # 创建部署脚本
          cat > install.sh << 'EOF'
          #!/bin/bash
          # iptux 安装脚本
          
          # 检查是否以root运行
          if [ "$(id -u)" != "0" ]; then
            echo "请以root权限运行此脚本"
            exit 1
          fi
          
          # 安装目录
          INSTALL_DIR="/usr/local"
          
          # 创建目录（如果不存在）
          mkdir -p $INSTALL_DIR/bin
          mkdir -p $INSTALL_DIR/lib
          mkdir -p $INSTALL_DIR/share
          
          # 复制文件
          echo "正在安装iptux..."
          
          # 智能处理不同结构的安装包
          if [ -d "usr/local" ]; then
            cp -r usr/local/bin/* $INSTALL_DIR/bin/ 2>/dev/null || echo "警告：bin目录复制失败或为空"
            cp -r usr/local/lib/* $INSTALL_DIR/lib/ 2>/dev/null || echo "警告：lib目录复制失败或为空" 
            cp -r usr/local/share/* $INSTALL_DIR/share/ 2>/dev/null || echo "警告：share目录复制失败或为空"
          fi
          
          if [ -d "usr" ]; then
            cp -r usr/bin/* $INSTALL_DIR/bin/ 2>/dev/null || true
            cp -r usr/lib/* $INSTALL_DIR/lib/ 2>/dev/null || true
            cp -r usr/share/* $INSTALL_DIR/share/ 2>/dev/null || true
          fi
          
          # 设置可执行权限
          find $INSTALL_DIR/bin -type f -exec chmod +x {} \; 2>/dev/null
          
          # 运行ldconfig更新共享库缓存
          echo "更新共享库缓存..."
          ldconfig
          
          echo "安装完成！请确保安装以下依赖:"
          cat dependencies.txt
          
          echo "iptux现在可以从命令行启动: iptux"
          EOF
          
          # 设置部署脚本权限
          chmod +x install.sh
          
          # 创建依赖列表
          cat > dependencies.txt << EOF
          # 以下是运行iptux所需的依赖
          libgtk-3-0
          libglib2.0-0
          libjsoncpp25 (或libjsoncpp24，取决于系统版本)
          libsigc++-2.0-0v5
          libgoogle-glog0v5
          libayatana-appindicator3-1
          
          # 安装命令参考
          # 对于Debian/Ubuntu系统:
          apt-get install -y libgtk-3-0 libglib2.0-0 libjsoncpp25 libsigc++-2.0-0v5 libgoogle-glog0v5 libayatana-appindicator3-1
          EOF
          
          # 创建一个README文件
          cat > README.md << EOF
          # iptux ${{ github.event.inputs.target_arch }} 安装指南
          
          ## 安装方法
          
          1. 解压安装包: \`tar xzf iptux-docker-${{ github.event.inputs.target_arch }}.tar.gz\`
          2. 确保您正在 ${{ github.event.inputs.target_arch }} 架构的设备上安装
          3. 安装依赖: \`sudo apt-get install -y \$(grep -v "^#" dependencies.txt | grep -v "取决于系统版本" | tr '\n' ' ')\`
          4. 以root权限运行安装脚本: \`sudo ./install.sh\`
          
          ## 故障排除
          
          如果遇到"共享库缺失"的错误，请确保已安装所有dependencies.txt中列出的依赖。
          
          ## 手动安装方法
          
          如果安装脚本不能正常工作，您可以手动安装:
          
          \`\`\`bash
          sudo mkdir -p /usr/local/bin /usr/local/lib /usr/local/share
          sudo cp -r usr/local/bin/* /usr/local/bin/ 2>/dev/null || true
          sudo cp -r usr/local/lib/* /usr/local/lib/ 2>/dev/null || true
          sudo cp -r usr/local/share/* /usr/local/share/ 2>/dev/null || true
          sudo cp -r usr/bin/* /usr/local/bin/ 2>/dev/null || true
          sudo cp -r usr/lib/* /usr/local/lib/ 2>/dev/null || true
          sudo cp -r usr/share/* /usr/local/share/ 2>/dev/null || true
          sudo find /usr/local/bin -type f -exec chmod +x {} \; 2>/dev/null
          sudo ldconfig
          \`\`\`
          EOF
          
          # 打包所有文件
          mkdir -p deploy
          cp -r pkg/* deploy/ 2>/dev/null || echo "警告：pkg目录复制失败或为空"
          cp install.sh dependencies.txt README.md deploy/
          
          # 打包为tar.gz
          cd deploy
          tar czf ../iptux-docker-${{ github.event.inputs.target_arch }}.tar.gz *
          cd ..
          
      - name: Upload artifacts
        uses: actions/upload-artifact@v4.6.1
        with:
          name: iptux-docker-${{ github.event.inputs.target_arch }}
          path: |
            deploy/
            iptux-docker-${{ github.event.inputs.target_arch }}.tar.gz
          retention-days: 7 